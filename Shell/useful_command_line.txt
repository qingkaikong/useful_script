#In this file, I will keep a record of some of the useful command line
#Note all these commands are tested under bash. 

#1 show the calendar
cal 2 1015

#1a show julian day
cal -jy

#2 list long format files sorted by reverse time order with human readable format
ls -ltrh

#3 redirect and append to file of the output of a program
ls -l /usr/bin > ls-output.txt
ls -l /usr/bin >> ls-output.txt

#4 bash references standard input, output, and error as file descriptors 0, 1, and 2
#so if I want to log the standard error into a file
ls -l /bin/usr 2> ls-error.txt

#5 if we want to redirect output and error into one file there are two ways
#a) two redirections, the second is redirect file descriptor 2 to file descriptor 1
ls -l /bin/usr > ls-output.txt 2>&1
#b) ls -l /bin/usr &> ls-output.txt

#6 Disposing unwanted output (just ignore)
ls -l /bin/usr 2> /dev/null

#7 use cat to create a new file
cat lazy_dag.txt

#8 pipeline
ls -l /usr/bin | less

#9 filters take input, change it somehow, and then output it
ls /bin /usr/bin | sort | less

#10 uniq accepts a sorted list of data from either standard input or a single 
#filename argument and removes any duplicates from the list. 
ls /bin /usr/bin | sort | uniq | less

#10b if we want to see the duplicates instead, we add -d option 
ls /bin /usr/bin | sort | uniq -d | less

#11 count the number of lines, words, and bytes
ls /bin /usr/bin | sort | uniq | wc -l 

#12 find files contain zip in the name, use -i option to ignore case, and -v only
#show the lines not match the pattern
ls /bin /usr/bin | sort | uniq | grep zip

#13 Monitoring log files in real time
tail -f /var/log/messages

#14 Using 'T' fitting on pipe, this will both output to the file and standard output
ls /usr/bin | tee ls.txt | grep zip

#15 Display two files side by side, -m merge the files, and -t to omit headers
# -w $Column to specify how many columns to display 
pr -m -t -w 100 one.txt two.txt

#16 Arithmetic expansion
echo $(($((5**2)) * 3))

#17 Brace Expansion
echo Front-{A,B,C}-Back
echo Number_{1..5}
echo {Z..A}
mkdir {2009..2011}-0{1..9} {2009..2011}-{10..12}

#18 command expansion
echo $(ls)

#19 Quoting, the effect of single quoting (suppress all expansions), double quoting
echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"

#20 if I have many files with the name A_20140101_B_C.data, I want to get the part which
#contains number (20140101), and count the number of files that contain unique number
ls *.data | awk -F "_" '{print $2}' | sort | uniq | wc














































