#In this file, I will keep a record of some of the useful command line
#Note all these commands are tested under bash. 

#1 show the calendar
cal 2 1015

#1a show julian day
cal -jy

#2 list long format files sorted by reverse time order with human readable format
ls -ltrh

#3 redirect and append to file of the output of a program
ls -l /usr/bin > ls-output.txt
ls -l /usr/bin >> ls-output.txt

#4 bash references standard input, output, and error as file descriptors 0, 1, and 2
#so if I want to log the standard error into a file
ls -l /bin/usr 2> ls-error.txt

#5 if we want to redirect output and error into one file there are two ways
#a) two redirections, the second is redirect file descriptor 2 to file descriptor 1
ls -l /bin/usr > ls-output.txt 2>&1
#b) ls -l /bin/usr &> ls-output.txt

#6 Disposing unwanted output (just ignore)
ls -l /bin/usr 2> /dev/null

#7 use cat to create a new file
cat lazy_dag.txt

#8 pipeline
ls -l /usr/bin | less

#9 filters take input, change it somehow, and then output it
ls /bin /usr/bin | sort | less

#10 uniq accepts a sorted list of data from either standard input or a single 
#filename argument and removes any duplicates from the list. 
ls /bin /usr/bin | sort | uniq | less

#10b if we want to see the duplicates instead, we add -d option 
ls /bin /usr/bin | sort | uniq -d | less

#11 count the number of lines, words, and bytes
ls /bin /usr/bin | sort | uniq | wc -l 

#12 find files contain zip in the name, use -i option to ignore case, and -v only
#show the lines not match the pattern
ls /bin /usr/bin | sort | uniq | grep zip

#13 Monitoring log files in real time
tail -f /var/log/messages

#14 Using 'T' fitting on pipe, this will both output to the file and standard output
ls /usr/bin | tee ls.txt | grep zip

#15 Display two files side by side, -m merge the files, and -t to omit headers
# -w $Column to specify how many columns to display 
pr -m -t -w 100 one.txt two.txt

#16 Arithmetic expansion
echo $(($((5**2)) * 3))

#17 Brace Expansion
echo Front-{A,B,C}-Back
echo Number_{1..5}
echo {Z..A}
mkdir {2009..2011}-0{1..9} {2009..2011}-{10..12}

#18 command expansion
echo $(ls)

#19 Quoting, the effect of single quoting (suppress all expansions), double quoting
echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"

#20 if I have many files with the name A_20140101_B_C.data, I want to get the part which
#contains number (20140101), and count the number of files that contain unique number
ls *.data | awk -F "_" '{print $2}' | sort | uniq | wc

#21 Check the history and use some of the previous commands
history
!22      #use the number 22 command
#more history expansion commands
!! Repeat the last command.
!number Repeat history list item number
!string Repeat last history list item starting with string
!?string Repeat last history list item containing string

#23 Viewing Processes
ps
ps x
ps aux

#24 Dynamic view of processes
top

#25 Put program in background
xlogo &
#put the program back to forefront 
jobs
fg %1

#26 kill a process
kill PID
killall name

#27 Show the environment variable
printenv
printenv USER

#28 set without argument will print out all the environment and shell variables
set | less
#same as alias
alias

#29 Check the size of the folder
du -hsc *
#showing the disk space
df












































